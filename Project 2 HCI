import streamlit as st
import requests
import pandas as pd
from datetime import datetime
import altair as alt
import numpy as np

# session state initialization
if 'weather_data' not in st.session_state:
    st.session_state['weather_data'] = None
if 'forecast_data' not in st.session_state:
    st.session_state['forecast_data'] = None
if 'selected_location' not in st.session_state:
    st.session_state['selected_location'] = None
if 'lat' not in st.session_state:
    st.session_state['lat'] = None
if 'lon' not in st.session_state:
    st.session_state['lon'] = None
if 'weather_fetched' not in st.session_state:
    st.session_state['weather_fetched'] = False

# background color picker
bg_color = st.sidebar.color_picker("Do you wish to change the background color? Click here üëá", "#9fe1f1")  # default light blue
st.markdown(
    f"""
    <style>
    .stApp {{
        background-color: {bg_color};
    }}
    </style>
    """,
    unsafe_allow_html=True
)

st.title("üå§Ô∏è Weather üå§Ô∏è")
st.markdown("Welcome! Please select a location to begin.")

API_KEY = "104b05380355d114211b792c6e638369"


# function to get latitude and longitude based on location, making the search more specific
def get_location_coordinates(location_input):
    geo_url = f"http://api.openweathermap.org/geo/1.0/direct?q={location_input}&limit=5&appid={API_KEY}"
    try:
        geo_response = requests.get(geo_url)
        geo_response.raise_for_status()
        locations = geo_response.json()

        if not locations:
            st.error("No matching locations found. Please check your input.")
            return None, None
        else:
            #provide location options to the user to select, more specific!
            options = [
                f"{loc.get('name', '')}, {loc.get('state', '') + ', ' if loc.get('state') else ''}{loc.get('country', '')}"
                for loc in locations
            ]

            selected_location = st.selectbox("Select the correct location:", options)

            #store the selected location and coordinates in session state
            idx = options.index(selected_location)
            st.session_state['selected_location'] = selected_location
            st.session_state['lat'] = locations[idx]['lat']
            st.session_state['lon'] = locations[idx]['lon']

            return locations[idx]['lat'], locations[idx]['lon']
    except requests.exceptions.RequestException as e:
        st.error(f"API request failed: {e}")
        return None, None

location_input = st.text_input("Enter location (city, state(optional), country code):", "Miami,FL,US")

#fetch location options only if input changes
if 'location_options' not in st.session_state or location_input != st.session_state.get('last_location_input', ''):
    geo_url = f"http://api.openweathermap.org/geo/1.0/direct?q={location_input}&limit=5&appid={API_KEY}"
    try:
        geo_response = requests.get(geo_url)
        geo_response.raise_for_status()
        locations = geo_response.json()

        if locations:
            st.session_state['location_options'] = [
                f"{loc.get('name', '')}, {loc.get('state', '') + ', ' if loc.get('state') else ''}{loc.get('country', '')}"
                for loc in locations
            ]
            st.session_state['location_data'] = locations
            st.session_state['last_location_input'] = location_input
            st.session_state['location_selected'] = False
        else:
            st.error("No matching locations found. Please check your input and try again.")
            st.stop()
    except requests.exceptions.RequestException as e:
        st.error(f"API request failed: {e}")
        st.stop()

# showing the dropdown if options exist
if 'location_options' in st.session_state:
    selected_location = st.selectbox("Select the correct location:", st.session_state['location_options'])

    #resetting state when selection changes
    if st.session_state.get('selected_location_dropdown') != selected_location:
        st.session_state['weather_fetched'] = False  #allowing new data fetch
        st.session_state['selected_location_dropdown'] = selected_location

# when the button is clicked, fetch the data - Requirement
if st.button("Get Weather") and not st.session_state['weather_fetched']:
    selected = st.session_state['selected_location_dropdown']
    idx = st.session_state['location_options'].index(selected)
    st.session_state['selected_location'] = selected
    st.session_state['lat'] = st.session_state['location_data'][idx]['lat']
    st.session_state['lon'] = st.session_state['location_data'][idx]['lon']
    st.session_state['location_selected'] = True

    lat = st.session_state['lat']
    lon = st.session_state['lon']

    weather_url = f"http://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API_KEY}&units=metric"
    forecast_url = f"https://api.openweathermap.org/data/2.5/forecast?lat={lat}&lon={lon}&appid={API_KEY}&units=metric"

    try:
        weather_response = requests.get(weather_url)
        forecast_response = requests.get(forecast_url)
        weather_response.raise_for_status()
        forecast_response.raise_for_status()

        st.session_state['weather_data'] = weather_response.json()
        st.session_state['forecast_data'] = forecast_response.json()
        st.session_state['weather_fetched'] = True
        st.success("Weather data loaded successfully!")

    except requests.exceptions.RequestException as e:
        st.error(f"Failed to fetch weather data: {e}")


# sidebar for page selection
page_selection = st.sidebar.radio(
    "Select a Page",
    ["üåç Weather Details", "üìà Forecast"]
)

# displaying information for weather details
if page_selection == "üåç Weather Details":

    if st.session_state['weather_data']:
        selected_location = st.session_state['selected_location']
        lat = st.session_state['lat']
        lon = st.session_state['lon']

        #map that shows the location the user picked - Requirement
        st.subheader("üìç Location on Map")
        st.map(pd.DataFrame({'lat': [lat], 'lon': [lon]}))

        #option for the user to see the coordinates by clicking a checkbox - Requirement
        show_coordinates = st.checkbox("Click to see coordinates of this location")
        if show_coordinates and lat and lon:
            st.info(f"Latitude: {lat}, Longitude: {lon}")


        st.subheader(f"Current Weather for {selected_location}")
        st.write(f"**Temperature:** {st.session_state['weather_data']['main']['temp']} ¬∞C")
        st.write(f"**Feels like:** {st.session_state['weather_data']['main']['feels_like']} ¬∞C")
        st.write(f"**Humidity:** {st.session_state['weather_data']['main']['humidity']}%")
        st.write(f"**Pressure:** {st.session_state['weather_data']['main']['pressure']} hPa")

        description = st.session_state['weather_data']['weather'][0]['description']
        description_lower = description.lower()

        #adding an emoji based on the weather using keywords. If no keyword found, default emoji
        emoji = "üåà"
        if "clear" in description_lower:
            emoji = "‚òÄÔ∏è"
        elif "cloud" in description_lower:
            emoji = "‚òÅÔ∏è"
        elif "rain" in description_lower:
            emoji = "üåßÔ∏è"
        elif "thunder" in description_lower:
            emoji = "üå©Ô∏è"
        elif "snow" in description_lower:
            emoji = "‚ùÑÔ∏è"
        elif "mist" in description_lower or "fog" in description_lower:
            emoji = "üå´Ô∏è"
        elif "drizzle" in description_lower:
            emoji = "üå¶Ô∏è"
        elif "haze" in description_lower:
            emoji = "üåÅ"
        elif "dust" in description_lower or "sand" in description_lower:
            emoji = "üå™Ô∏è"

        st.write(f"**Weather:** {description.title()} {emoji}")
        st.write(f"**Wind Speed:** {st.session_state['weather_data']['wind']['speed']} m/s")

        #information for chart
        temp_c = st.session_state['weather_data']['main']['temp']
        feels_like_c = st.session_state['weather_data']['main']['feels_like']
        temp_min_c = st.session_state['weather_data']['main']['temp_min']
        temp_max_c = st.session_state['weather_data']['main']['temp_max']

        temp_f = temp_c * 9 / 5 + 32
        feels_like_f = feels_like_c * 9 / 5 + 32
        temp_min_f = temp_min_c * 9 / 5 + 32
        temp_max_f = temp_max_c * 9 / 5 + 32

        st.subheader("Temperature Details (Celsius and Fahrenheit)")

        temp_df = pd.DataFrame({
            'Temperature Measurements': ['Temperature', 'Feels Like', 'Min Temp', 'Max Temp'],
            'Metric (¬∞C)': [f"{temp_c:.1f}", f"{feels_like_c:.1f}", f"{temp_min_c:.1f}", f"{temp_max_c:.1f}"],
            'Imperial (¬∞F)': [f"{temp_f:.1f}", f"{feels_like_f:.1f}", f"{temp_min_f:.1f}", f"{temp_max_f:.1f}"]
        })

        st.markdown(
            """
            <style>
            table { width: 100%; }
            th, td { text-align: center !important; }
            </style>
            """,
            unsafe_allow_html=True
        )

        #displaying table - Requirement
        st.dataframe(temp_df)

        st.write("üìö If you would like to see forecast data, please select 'Forecast' from the sidebar.")
        st.info(f"Data retrieved on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")

#page selection for forecast data
elif page_selection == "üìà Forecast":

    st.subheader("üìÖ Forecast")

    #setting up metrics for the forecast graphs
    if st.session_state['forecast_data']:
        forecast_data = st.session_state['forecast_data']
        hourly = forecast_data['list'][:8]
        times = [datetime.strptime(h['dt_txt'], '%Y-%m-%d %H:%M:%S') for h in hourly]
        temps = np.array([h['main']['temp'] for h in hourly])
        humidity = [h['main']['humidity'] for h in hourly]
        wind_speeds = [h['wind']['speed'] for h in hourly]
        precipitation = []
        for h in hourly:
            rain = h.get('rain', {}).get('3h', 0.0)
            snow = h.get('snow', {}).get('3h', 0.0)
            try:
                total_precip = float(rain) + float(snow)
            except (TypeError, ValueError):
                total_precip = 0.0  # fallback if API returns something unexpected
            precipitation.append(total_precip)
        pressure = [h['main']['pressure'] for h in hourly]


        df_hourly = pd.DataFrame({
            'Date': [t.strftime('%Y-%m-%d') for t in times],
            'Time': [t.strftime('%I:%M %p') for t in times],
            'Temperature (¬∞C)': temps,
            'Temperature (¬∞F)': [f"{(t * 9 / 5) + 32:.2f}" for t in temps],
            'Humidity (%)': humidity,
            'Wind Speed (m/s)': wind_speeds,
            'Precipitation (mm)': precipitation,
            'Pressure (hPa)': pressure,
        })

        df_hourly['DateTime'] = [datetime.strptime(f"{d} {t}", '%Y-%m-%d %I:%M %p') for d, t in
                                 zip(df_hourly['Date'], df_hourly['Time'])]
        df_hourly = df_hourly.sort_values('DateTime')

        st.markdown("**üîπ Select a metric you would like to explore!**")
        metric = st.selectbox("Select a metric (hourly forecast):", ['Temperature', 'Humidity', 'Wind Speed','Precipitation','Pressure'])


        #showing the data inside the graphs (place mouse over the points to get information)
        if metric == 'Temperature':
            y_col = 'Temperature (¬∞C)'
            tooltip = [
                alt.Tooltip('Date', title='Date'),
                alt.Tooltip('Time', title='Time'),
                alt.Tooltip('Temperature (¬∞C)', title='Temp (¬∞C)'),
                alt.Tooltip('Temperature (¬∞F)', title='Temp (¬∞F)'),
            ]
        elif metric == 'Humidity':
            y_col = 'Humidity (%)'
            tooltip = [
                alt.Tooltip('Date', title='Date'),
                alt.Tooltip('Time', title='Time'),
                alt.Tooltip('Humidity (%)', title='Humidity (%)'),
            ]
        elif metric == 'Wind Speed':
            y_col = 'Wind Speed (m/s)'
            tooltip = [
                alt.Tooltip('Date', title='Date'),
                alt.Tooltip('Time', title='Time'),
                alt.Tooltip('Wind Speed (m/s)', title='Wind Speed (m/s)'),
            ]
        elif metric == 'Precipitation':
            y_col = 'Precipitation (mm)'
            tooltip = [
            alt.Tooltip('Date', title='Date'),
            alt.Tooltip('Time', title='Time'),
            alt.Tooltip('Precipitation (mm)', title='Precipitation (mm)'),
            ]
        else:
            y_col = 'Pressure (hPa)'
            tooltip = [
                alt.Tooltip('Date', title='Date'),
                alt.Tooltip('Time', title='Time'),
                alt.Tooltip('Pressure (hPa)', title='Pressure (hPa)'),
            ]



        chart = alt.Chart(df_hourly).mark_line(point=True).encode(
            x=alt.X('DateTime:T', title='Time', axis=alt.Axis(format='%I:%M %p', labelAngle=-45)),
            y=alt.Y(y_col, title=metric),
            tooltip=tooltip
        ).properties(
            width=700,
            height=400,
            title=f"{metric} over Time"
        )

        #displaying chart - Requirement
        st.altair_chart(chart, use_container_width=True)


        #information about each metric under graphs, with interactive sliders
        with st.expander(f"‚ÑπÔ∏è Learn more about {metric}"):
            if metric == 'Temperature':
                st.markdown("""
                        **üå°Ô∏è Temperature** shows how hot or cold the air will feel during the forecasted time period.  
                        
                        **üåàFun Fact!**
                        The coldest temperature ever recorded on Earth was ‚àí89.2 ¬∞C (‚àí128.6 ¬∞F), in Antarctica!
                        
                        _Would you like to see how the air will feel depending on the temperature?_
                        """)

                temperature = st.slider("Select temperature (¬∞C)", -5, 45, 20)

                if temperature <= 0:
                    st.info("‚ùÑÔ∏è Freezing ‚Äî dress warmly to prevent frostbite.")
                elif temperature <= 10:
                    st.info("ü•∂ Cold ‚Äî jacket weather; consider layering up.")
                elif temperature <= 20:
                    st.info("üß• Cool ‚Äî light jacket or sweater recommended.")
                elif temperature <= 25:
                    st.warning("üòå Comfortable ‚Äî mild and pleasant temperature.")
                elif temperature <= 30:
                    st.warning("üå§Ô∏è Warm ‚Äî stay hydrated and wear light clothing.")
                else:
                    st.error("ü•µ Hot ‚Äî avoid direct sun and take cooling breaks.")

                st.write("üîÑÔ∏è **To convert from Celsius to Fahrenheit, input the number here:**")
                temp_c = st.number_input("Temperature (¬∞C)", min_value=-100.0, max_value=100.0, value=20.0, step=0.1)
                temp_f = (temp_c * 9 / 5) + 32

                st.success(f"üå°Ô∏è {temp_c:.1f}¬∞C is equal to {temp_f:.1f}¬∞F")

            if metric == 'Humidity':
                st.markdown("""
                        **üíß Humidity** is the amount of water vapor in the air, and it is measured as a percentage (%).  
                    
                        **üåàFun Fact!**
                        It is easier to detect smells in a humid environment, since there are more water molecules in the air that carry particles into our nose!
                        
                        _Would you like to see how each humidity percentage will feel like?_
                        """)


                humidity = st.slider("Select humidity level (%)", 0, 100, 50)

                if humidity < 31:
                    st.warning("üî• Very dry air ‚Äî can feel crisp or arid.")
                elif humidity < 51:
                    st.success("üåø Comfortable and dry.")
                elif humidity < 71:
                    st.info("üå§Ô∏è Slightly humid ‚Äî warm but tolerable.")
                elif humidity < 86:
                    st.warning("üå´Ô∏è Humid ‚Äî sticky, sweaty feeling.")
                else:
                    st.error("üß™ Very humid ‚Äî air feels heavy and damp.")

            if metric == 'Wind Speed':
                st.markdown("""
                        **üçÉ Wind Speed** means how fast the air is moving, measured in meters per second (m/s).    
                        
                        
                        **üåàFun Fact!**
                        Once a storm's wind gets to about 33 m/s, it is considered a hurricane!
                        
                        _Would you like to see how different wind speeds feel?_
                        """)
                wind_speed = st.slider("Select wind speed (m/s)", 0.0, 15.0, 5.0, step=0.1)

                if wind_speed <= 1.5:
                    st.success("üçÉ Calm ‚Äî barely noticeable.")
                elif wind_speed <= 3.5:
                    st.success("üí® Light breeze ‚Äî rustles leaves.")
                elif wind_speed <= 8:
                    st.info("üå¨Ô∏è Moderate breeze ‚Äî leaves sway.")
                elif wind_speed <= 13.5:
                    st.warning("üå™Ô∏è Strong breeze ‚Äî noticeable resistance.")
                else:
                    st.error("üåÄ Very strong wind ‚Äî secure loose items!")
            if metric == 'Precipitation':
                st.markdown("""
                    **‚òî Precipitation (mm)** shows how much rain or snow is expected over each 3-hour period. It is measured in millimeters.  
                    
                    **üåàFun Fact!**
                    It takes a raindrop about 2 minutes to reach the ground!
                    
                    _Would you like to see what conditions you should expect based on the precipitation level?_
                    """)


                threshold = st.slider("Choose precipitation level (mm):", 0, 10, 1)


                if threshold == 0:
                    st.warning("‚òÄÔ∏è Expect dry conditions.")
                elif 1 <= threshold <= 2:
                    st.info("üå¶Ô∏è Light precipitation expected.")
                elif 3 <= threshold <= 5:
                    st.info("üåßÔ∏è Moderate precipitation expected.")
                else:
                    st.error("‚õàÔ∏è Heavy precipitation likely.")

            if metric == 'Pressure':
                st.markdown("""
                   **‚¨ÜÔ∏èüí® Pressure** is the weight of the air pressing down on Earth‚Äôs surface, measured in hectopascals (hPa).  
                   
                   **üåàFun Fact!**
                   As altitude increases, pressure decreases. This causes available oxygen to also decrease, which is why mountain climbers need to use bottled oxygen to climb safely!
                   
                   _Would you like to see how pressure affects weather?_
                   """)

                pressure = st.slider("Select pressure level (hPa)", 980, 1040, 1013)

                if pressure < 995:
                    st.warning("üåßÔ∏è Very low pressure ‚Äî possible stormy or unsettled weather.")
                elif pressure < 1005:
                    st.info("üå•Ô∏è Low pressure ‚Äî clouds and possible rain.")
                elif pressure <= 1025:
                    st.success("‚õÖ Normal range ‚Äî fair weather likely.")
                else:
                    st.warning("‚òÄÔ∏è High pressure ‚Äî clear, stable, and dry conditions.")

        st.write("üìö If you would like to see current weather details, please select 'Weather Details' from the sidebar.")

        #retrieving the date and time, ensures the data is current and up to date
        st.info(f"Data retrieved on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
